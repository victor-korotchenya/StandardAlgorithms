#pragma once
#include"../Utilities/check_size.h"
#include"../Utilities/require_utilities.h"
#include"longest_int.h"
#include<vector>

namespace Standard::Algorithms::Numbers::Inner
{
    template<std::integral int_t, int_t mod>
    requires(1 < mod)
    [[nodiscard]] constexpr auto count_adjacent_swaps(const std::string &str) -> int_t
    {
        using long_int_t = longest_int<int_t>;

        long_int_t swaps{};
        long_int_t ones{};

        for (const auto &cpr : str)
        {
            if (0 == cpr)
            {// 11110 - to move zero to the left of x ones, it takes x steps.
                swaps += ones;
            }
            else
            {
                assert(cpr == 1);

                ++ones;
            }
        }

        return static_cast<int_t>(swaps % mod);
    }

    template<std::integral int_t, int_t mod>
    requires(1 < mod)
    [[nodiscard]] constexpr auto string_pattern_adjacent_swap_count_slow_rec(std::string &str, int_t pos) -> int_t
    {
        constexpr int_t zero{};

        if (pos-- == zero)
        {
            const auto waps = count_adjacent_swaps<int_t, mod>(str);

            assert(!(waps < zero) && waps < mod);

            return waps;
        }

        auto &cha = str[pos];

        if (const auto no_question = cha != '?' - '0'; no_question)
        {
            return string_pattern_adjacent_swap_count_slow_rec<int_t, mod>(str, pos);
        }

        cha = 0;
        const auto nulls = string_pattern_adjacent_swap_count_slow_rec<int_t, mod>(str, pos);

        cha = 1;
        const auto ones = string_pattern_adjacent_swap_count_slow_rec<int_t, mod>(str, pos);
        cha = '?' - '0';

        auto swaps = static_cast<int_t>(nulls + ones);

        if (!(swaps < mod))
        {
            swaps -= mod;
        }

        assert(!(swaps < zero) && swaps < mod);

        return swaps;
    }
} // namespace Standard::Algorithms::Numbers::Inner

namespace Standard::Algorithms::Numbers
{
    // A string consists of "01?", where '?' can be '0' or '1'.
    // Count min total adjacent swaps to sort all generated strings modulo mod.
    // Example pattern "?0?" generates 4 strings having 3 total swaps:
    // "000" is already sorted, contributes none,
    // "001" also 0,
    // "100" must have minimum 2 adjacent moves to get a sorted string: "100" -> "010" -> "001".
    // "101" - 1 move from "101" to "011".
    // Assume that the input string length does not exceed 1E9.
    template<std::integral int_t, int_t mod>
    requires(1 < mod)
    [[nodiscard]] constexpr auto string_pattern_adjacent_swap_count(const std::string &pattern) -> int_t
    {
        using long_int_t = longest_int<int_t>;

        constexpr long_int_t zero{};

        long_int_t swaps{};
        long_int_t ones{};
        long_int_t questions{};
        long_int_t power2_q_minus1 = 1;

        for (const auto &cha : pattern)
        {
            assert(!(swaps < zero) && swaps < mod && (cha == '0' || cha == '1' || cha == '?'));

            if (cha == '1')
            {// Ones at the end are harmless for now.
                if (!(++ones < mod))
                {
                    ones -= mod;
                }

                continue;
            }

            const auto is_question = cha == '?';

            if (is_question)
            {// Every inversion before must be repeated.
                // "1100" has 4 swaps.
                // "11000" has 4 + 2 = 6, and "11001" has 4.
                // So, "1100?" has 4*2 + 2 = 10 swaps.
                swaps *= 2;

                // + 2 will be done below.
            }

            if (zero < questions)
            {
                // "1?1??11010" + "0"; or when the last "?" becomes "0" as in:
                // "1?1??11010" + "?"
                swaps +=
                    // All ones (for every string of 2**questions) must be moved after the current 0.
                    ones * 2 * power2_q_minus1 +
                    // Let questions=3; there are 2**3 = 8 strings each of size 3, producing 24 chars in total;
                    // half are 0s, and half 1s, 24/2 = 12 in each half.
                    //
                    // All 8 strings, generated by "???", have 1+2+1+2 = 6 total swaps,
                    // which have already been accounted for before:
                    // - 000, 001, 010 (+1), 011,
                    // - 100 (+2), 101 (+1), 110 (+2), 111.
                    //
                    // Check all 8 possibilities, created by "???" + "0":
                    // - 0000, 0010 (+1), 0100 (+2), 0110 (+2),
                    // - 1000 (+3), 1010 (+3), 1100 (+4), 1110 (+3).
                    // "???0" has swaps: (+1) (+2) (+2)  (+3) (+3)  (+4) (+3) = 5 + 6 + 7 = 18.
                    // Thus, placing '0' after "???" adds 18-6 = 12 swaps = questions * 2**(questions-1).
                    questions * power2_q_minus1; // Suppose no overflow here.
            }
            else
            {// No questions. Must move 1s past the current "0".
                // "111010" + "0"; or when the last "?" becomes "0" as in:
                // "111010" + "?"
                swaps += ones;
            }

            swaps %= mod;

            if (is_question && zero < questions++)
            {
                power2_q_minus1 *= 2;

                if (!(power2_q_minus1 < mod))
                {
                    power2_q_minus1 -= mod;
                }
            }
        }

        assert(!(swaps < zero) && swaps < mod);

        return static_cast<int_t>(swaps);
    }

    // Slow time O(2**q * n).
    template<std::integral int_t, int_t mod>
    requires(1 < mod)
    [[nodiscard]] constexpr auto string_pattern_adjacent_swap_count_slow(const std::string &pattern) -> int_t
    {
        const auto *const name = "pattern size";
        const auto size = Standard::Algorithms::Utilities::check_size<int_t>(name, pattern.size());
        require_positive(size, name);

        {
            constexpr int_t max_size = 20;

            require_less_equal(size, max_size, name);
        }

        constexpr int_t zero{};

        auto str = pattern;

        for (int_t index{}; index < size; ++index)
        {
            auto &cha = str[index];
            cha -= '0';

            assert(0 == cha || cha == 1 || cha == '?' - '0');
        }

        const auto swaps = Inner::string_pattern_adjacent_swap_count_slow_rec<int_t, mod>(str, size);

        assert(!(swaps < zero) && swaps < mod);

        return swaps;
    }
} // namespace Standard::Algorithms::Numbers
